# 1.2 API Design Principles

## SOLID Principles Applied to APIs
![SOLID](./images/ch1/1.2.1.solid-principles-api.svg)

### Single Responsibility Principle (SRP)
1. **API Endpoints**
   - Each endpoint should handle one specific business capability
   - Avoid combining multiple unrelated operations
   - Example: Separate user profile and user orders endpoints

2. **Resource Design**
   - Resources should represent single business entities
   - Avoid mixing concerns within resources
   - Clear separation of resource responsibilities

3. **Implementation Guidelines**
   ```sh
   Good:
   /users/{id}/profile
   /users/{id}/orders
   
   Bad:
   /users/{id}/profile-and-orders
   ```
   #### Typescript
   ```typescript
   
   // types.ts
   interface User {
      id: string;
      name: string;
      email: string;
   }

   interface Profile {
      bio: string;
      location: string;
      avatarUrl: string;
   }

   interface Order {
      id: string;
      userId: string;
      amount: number;
      status: 'pending' | 'completed' | 'cancelled';
      createdAt: Date;
   }

   // routes/users.ts
   import express from 'express';
   import { Router } from 'express';

   const router = Router();

   // Good: Separate endpoints for different resources
   router.get('/users/:id/profile', async (req: express.Request, res: express.Response) => {
   try {
      const userId = req.params.id;
      const profile = await ProfileService.getByUserId(userId);
      res.json(profile);
   } catch (error) {
      res.status(500).json({ error: 'Failed to fetch profile' });
   }
   });

   router.get('/users/:id/orders', async (req: express.Request, res: express.Response) => {
   try {
      const userId = req.params.id;
      const orders = await OrderService.getByUserId(userId);
      res.json(orders);
   } catch (error) {
      res.status(500).json({ error: 'Failed to fetch orders' });
   }
   });

   // Bad: Combined endpoint that violates separation of concerns
   router.get('/users/:id/profile-and-orders', async (req: express.Request, res: express.Response) => {
   try {
      const userId = req.params.id;
      const [profile, orders] = await Promise.all([
         ProfileService.getByUserId(userId),
         OrderService.getByUserId(userId)
      ]);
      res.json({ profile, orders }); // Tightly couples different resources
   } catch (error) {
      res.status(500).json({ error: 'Failed to fetch profile and orders' });
   }
   });

   export default router;
   ```

   #### Golang
   ```go
   // models/models.go
   package models

   type User struct {
      ID    string `json:"id"`
      Name  string `json:"name"`
      Email string `json:"email"`
   }

   type Profile struct {
      UserID    string `json:"userId"`
      Bio       string `json:"bio"`
      Location  string `json:"location"`
      AvatarURL string `json:"avatarUrl"`
   }

   type Order struct {
      ID        string    `json:"id"`
      UserID    string    `json:"userId"`
      Amount    float64   `json:"amount"`
      Status    string    `json:"status"`
      CreatedAt time.Time `json:"createdAt"`
   }

   // handlers/users.go
   package handlers

   import (
      "net/http"
      "github.com/gorilla/mux"
   )

   // Good: Separate handlers for different resources
   func GetUserProfile(w http.ResponseWriter, r *http.Request) {
      vars := mux.Vars(r)
      userID := vars["id"]
      
      profile, err := services.GetProfileByUserID(userID)
      if err != nil {
         http.Error(w, "Failed to fetch profile", http.StatusInternalServerError)
         return
      }
      
      json.NewEncoder(w).Encode(profile)
   }

   func GetUserOrders(w http.ResponseWriter, r *http.Request) {
      vars := mux.Vars(r)
      userID := vars["id"]
      
      orders, err := services.GetOrdersByUserID(userID)
      if err != nil {
         http.Error(w, "Failed to fetch orders", http.StatusInternalServerError)
         return
      }
      
      json.NewEncoder(w).Encode(orders)
   }

   // Bad: Combined handler that violates separation of concerns
   func GetUserProfileAndOrders(w http.ResponseWriter, r *http.Request) {
      vars := mux.Vars(r)
      userID := vars["id"]
      
      profile, err := services.GetProfileByUserID(userID)
      if err != nil {
         http.Error(w, "Failed to fetch profile", http.StatusInternalServerError)
         return
      }
      
      orders, err := services.GetOrdersByUserID(userID)
      if err != nil {
         http.Error(w, "Failed to fetch orders", http.StatusInternalServerError)
         return
      }
      
      // Tightly couples different resources
      response := struct {
         Profile Profile `json:"profile"`
         Orders  []Order `json:"orders"`
      }{
         Profile: profile,
         Orders:  orders,
      }
      
      json.NewEncoder(w).Encode(response)
   }

   // main.go
   func main() {
      router := mux.NewRouter()
      
      // Good: Register separate endpoints
      router.HandleFunc("/users/{id}/profile", handlers.GetUserProfile).Methods("GET")
      router.HandleFunc("/users/{id}/orders", handlers.GetUserOrders).Methods("GET")
      
      // Bad: Combined endpoint
      router.HandleFunc("/users/{id}/profile-and-orders", handlers.GetUserProfileAndOrders).Methods("GET")
      
      http.ListenAndServe(":8080", router)
   }
   ```

### Open/Closed Principle (OCP)
1. **API Extension**
   - Design for extensibility without modifying existing endpoints
   - Use versioning to introduce breaking changes
   - Support optional parameters and fields

2. **Implementation Strategies**
   - Query parameters for optional functionality
   - Response envelopes for extensible responses
   - Custom headers for additional features

3. **Practical Examples**
   ```sh
   Extensible:
   GET /api/v1/users?include=orders,preferences
   
   Version-based:
   GET /api/v2/users (new features)
   GET /api/v1/users (maintains backward compatibility)
   ```
   #### Type Script
   ```typescript
   // types.ts
   interface BaseUser {
      id: string;
      email: string;
      name: string;
   }

   interface Order {
      id: string;
      amount: number;
      status: string;
   }

   interface Preferences {
      theme: string;
      notifications: boolean;
      language: string;
   }

   // v2 adds new fields
   interface UserV2 extends BaseUser {
      phoneNumber?: string;
      twoFactorEnabled: boolean;
   }

   // services/user.service.ts
   class UserService {
   private async getBaseUser(id: string): Promise<BaseUser> {
      // Fetch base user data
      return {} as BaseUser;
   }

   private async getOrders(userId: string): Promise<Order[]> {
      // Fetch orders
      return [] as Order[];
   }

   private async getPreferences(userId: string): Promise<Preferences> {
      // Fetch preferences
      return {} as Preferences;
   }

   // Extensible approach using includes
   async getUserWithIncludes(
      id: string,
      includes: string[]
   ): Promise<Record<string, any>> {
      const result: Record<string, any> = {
         user: await this.getBaseUser(id),
      };

      const includeSet = new Set(includes);

      if (includeSet.has('orders')) {
         result.orders = await this.getOrders(id);
      }

      if (includeSet.has('preferences')) {
         result.preferences = await this.getPreferences(id);
      }

      return result;
   }
   }

   // controllers/user.controller.ts
   import { Router } from 'express';
   const router = Router();
   const userService = new UserService();

   // Approach 1: Extensible using query parameters
   router.get('/api/v1/users/:id', async (req, res) => {
   try {
      const { id } = req.params;
      const includes = (req.query.include as string || '')
         .split(',')
         .filter(Boolean);

      const result = await userService.getUserWithIncludes(id, includes);
      res.json(result);
   } catch (error) {
      res.status(500).json({ error: 'Failed to fetch user data' });
   }
   });

   // Approach 2: Version-based
   // V1 API maintains original behavior
   router.get('/api/v1/users/:id', async (req, res) => {
   try {
      const { id } = req.params;
      const baseUser = await userService.getUserWithIncludes(id, []);
      res.json(baseUser);
   } catch (error) {
      res.status(500).json({ error: 'Failed to fetch user data' });
   }
   });

   // V2 API adds new features
   router.get('/api/v2/users/:id', async (req, res) => {
   try {
      const { id } = req.params;
      const baseUser = await userService.getUserWithIncludes(id, []);
      const userV2: UserV2 = {
         ...baseUser.user,
         phoneNumber: '123-456-7890', // New field in V2
         twoFactorEnabled: true,      // New field in V2
      };
      res.json(userV2);
   } catch (error) {
      res.status(500).json({ error: 'Failed to fetch user data' });
   }
   });
   ```
   #### Golang
   ```go
   package main

   import (
      "encoding/json"
      "net/http"
      "strings"
      "github.com/gorilla/mux"
   )

   // Models
   type BaseUser struct {
      ID    string `json:"id"`
      Email string `json:"email"`
      Name  string `json:"name"`
   }

   type UserV2 struct {
      BaseUser
      PhoneNumber      string `json:"phoneNumber,omitempty"`
      TwoFactorEnabled bool   `json:"twoFactorEnabled"`
   }

   type Order struct {
      ID     string  `json:"id"`
      Amount float64 `json:"amount"`
      Status string  `json:"status"`
   }

   type Preferences struct {
      Theme         string `json:"theme"`
      Notifications bool   `json:"notifications"`
      Language      string `json:"language"`
   }

   // Services
   type UserService struct{}

   func (s *UserService) GetBaseUser(id string) (*BaseUser, error) {
      // Fetch base user data
      return &BaseUser{}, nil
   }

   func (s *UserService) GetOrders(userID string) ([]Order, error) {
      // Fetch orders
      return []Order{}, nil
   }

   func (s *UserService) GetPreferences(userID string) (*Preferences, error) {
      // Fetch preferences
      return &Preferences{}, nil
   }

   // Response builder using the builder pattern
   type UserResponseBuilder struct {
      data map[string]interface{}
   }

   func NewUserResponseBuilder(user *BaseUser) *UserResponseBuilder {
      return &UserResponseBuilder{
         data: map[string]interface{}{
               "user": user,
         },
      }
   }

   func (b *UserResponseBuilder) WithOrders(orders []Order) *UserResponseBuilder {
      b.data["orders"] = orders
      return b
   }

   func (b *UserResponseBuilder) WithPreferences(prefs *Preferences) *UserResponseBuilder {
      b.data["preferences"] = prefs
      return b
   }

   func (b *UserResponseBuilder) Build() map[string]interface{} {
      return b.data
   }

   // Handlers
   type UserHandler struct {
      service *UserService
   }

   // Approach 1: Extensible using query parameters
   func (h *UserHandler) GetUserWithIncludes(w http.ResponseWriter, r *http.Request) {
      vars := mux.Vars(r)
      userID := vars["id"]
      
      includes := strings.Split(r.URL.Query().Get("include"), ",")
      includeSet := make(map[string]bool)
      for _, include := range includes {
         if include != "" {
               includeSet[include] = true
         }
      }
      
      user, err := h.service.GetBaseUser(userID)
      if err != nil {
         http.Error(w, "Failed to fetch user", http.StatusInternalServerError)
         return
      }
      
      builder := NewUserResponseBuilder(user)
      
      if includeSet["orders"] {
         orders, err := h.service.GetOrders(userID)
         if err == nil {
               builder.WithOrders(orders)
         }
      }
      
      if includeSet["preferences"] {
         prefs, err := h.service.GetPreferences(userID)
         if err == nil {
               builder.WithPreferences(prefs)
         }
      }
      
      json.NewEncoder(w).Encode(builder.Build())
   }

   // Approach 2: Version-based API
   // V1 API - Original version
   func (h *UserHandler) GetUserV1(w http.ResponseWriter, r *http.Request) {
      vars := mux.Vars(r)
      userID := vars["id"]
      
      user, err := h.service.GetBaseUser(userID)
      if err != nil {
         http.Error(w, "Failed to fetch user", http.StatusInternalServerError)
         return
      }
      
      json.NewEncoder(w).Encode(user)
   }

   // V2 API - New version with additional fields
   func (h *UserHandler) GetUserV2(w http.ResponseWriter, r *http.Request) {
      vars := mux.Vars(r)
      userID := vars["id"]
      
      baseUser, err := h.service.GetBaseUser(userID)
      if err != nil {
         http.Error(w, "Failed to fetch user", http.StatusInternalServerError)
         return
      }
      
      // Extend with V2 fields
      userV2 := UserV2{
         BaseUser:        *baseUser,
         PhoneNumber:     "123-456-7890",
         TwoFactorEnabled: true,
      }
      
      json.NewEncoder(w).Encode(userV2)
   }

   func main() {
      router := mux.NewRouter()
      handler := &UserHandler{service: &UserService{}}
      
      // Approach 1: Extensible endpoint
      router.HandleFunc("/api/v1/users/{id}", handler.GetUserWithIncludes).
         Methods("GET").
         Queries("include", "{include}")
      
      // Approach 2: Versioned endpoints
      router.HandleFunc("/api/v1/users/{id}", handler.GetUserV1).Methods("GET")
      router.HandleFunc("/api/v2/users/{id}", handler.GetUserV2).Methods("GET")
      
      http.ListenAndServe(":8080", router)
   }
   ```

   #### Type Script GraphQL
   ```typescript
   // types.ts
   export interface BaseUser {
      id: string;
      email: string;
      name: string;
      phoneNumber?: string;
      twoFactorEnabled?: boolean;
   }

   export interface Order {
      id: string;
      amount: number;
      status: string;
   }

   export interface Preferences {
      theme: string;
      notifications: boolean;
      language: string;
   }

   // services/user.service.ts
   export class UserService {
   private async getBaseUser(id: string): Promise<BaseUser> {
      // Fetch base user data
      return {} as BaseUser;
   }

   private async getOrders(userId: string): Promise<Order[]> {
      // Fetch orders
      return [] as Order[];
   }

   private async getPreferences(userId: string): Promise<Preferences> {
      // Fetch preferences
      return {} as Preferences;
   }

   async getUserV1Data(id: string): Promise<BaseUser> {
      const user = await this.getBaseUser(id);
      // V1 only returns base fields
      const { id: userId, email, name } = user;
      return { id: userId, email, name };
   }

   async getUserV2Data(id: string): Promise<BaseUser> {
      const baseUser = await this.getBaseUser(id);
      return {
         ...baseUser,
         phoneNumber: '123-456-7890',
         twoFactorEnabled: true
      };
   }

   async getUserOrders(userId: string): Promise<Order[]> {
      return this.getOrders(userId);
   }

   async getUserPreferences(userId: string): Promise<Preferences> {
      return this.getPreferences(userId);
   }
   }

   // schema.graphql
   const typeDefs = `#graphql
   type Order {
      id: ID!
      amount: Float!
      status: String!
   }

   type Preferences {
      theme: String!
      notifications: Boolean!
      language: String!
   }

   type BaseUser {
      id: ID!
      email: String!
      name: String!
      phoneNumber: String
      twoFactorEnabled: Boolean
      orders: [Order!]
      preferences: Preferences
   }

   type Query {
      # V1 Query - returns only base fields
      userV1(id: ID!): BaseUser!
      
      # V2 Query - returns all fields including phone and 2FA
      userV2(id: ID!): BaseUser!
   }
   `;

   // resolvers.ts
   import { UserService } from './services/user.service';

   const userService = new UserService();

   const resolvers = {
   Query: {
      userV1: async (_: any, { id }: { id: string }) => {
         return userService.getUserV1Data(id);
      },
      userV2: async (_: any, { id }: { id: string }) => {
         return userService.getUserV2Data(id);
      },
   },
   BaseUser: {
      orders: async (parent: BaseUser) => {
         return userService.getUserOrders(parent.id);
      },
      preferences: async (parent: BaseUser) => {
         return userService.getUserPreferences(parent.id);
      },
   },
   };

   // server.ts
   import { ApolloServer } from '@apollo/server';
   import { startStandaloneServer } from '@apollo/server/standalone';

   const server = new ApolloServer({
   typeDefs,
   resolvers,
   });

   const { url } = await startStandaloneServer(server, {
   listen: { port: 4000 },
   });

   console.log(`🚀 Server ready at: ${url}`);

   ```

   ```json
    // Example queries:
      # V1 Query - Only base fields will be returned, even if V2 fields are requested
      query GetUserV1 {
         userV1(id: "123") {
            id
            email
            name
            phoneNumber  # Will be null
            twoFactorEnabled  # Will be null
            orders {
               id
               amount
               status
            }
            preferences {
               theme
               notifications
               language
            }
         }
      }

      # V2 Query - All fields available
      query GetUserV2 {
         userV2(id: "123") {
            id
            email
            name
            phoneNumber
            twoFactorEnabled
            orders {
               id
               amount
               status
            }
            preferences {
               theme
               notifications
               language
            }
         }
      }

      # V2 Query - Can still request only V1 fields if desired
      query GetUserV2BasicFields {
         userV2(id: "123") {
            id
            email
            name
         }
      }

   ```

### Liskov Substitution Principle (LSP)
1. **Resource Inheritance**
   - Subtypes must be substitutable for their base types
   - Maintain consistent behavior across resource variants
   - Preserve contract expectations

2. **Response Consistency**
   - Consistent error handling
   - Predictable response structures
   - Compatible data types

3. **Example Implementation**
   ```json
   Base Response:
   {
     "id": "string",
     "type": "string",
     "attributes": {}
   }

   Derived Responses must maintain this structure
   ```

   #### Type Script
   ```typescript
      // types/response.ts
      interface BaseResponse<T> {
         id: string;
         type: string;
         attributes: T;
      }

      // Attribute interfaces for different resources
      interface UserAttributes {
         email: string;
         name: string;
         createdAt: Date;
      }

      interface OrderAttributes {
         total: number;
         status: 'pending' | 'completed' | 'cancelled';
         items: number;
         orderedAt: Date;
      }

      interface ProductAttributes {
         name: string;
         price: number;
         stock: number;
         category: string;
      }

      // Response type aliases for better readability
      type UserResponse = BaseResponse<UserAttributes>;
      type OrderResponse = BaseResponse<OrderAttributes>;
      type ProductResponse = BaseResponse<ProductAttributes>;

      // Base response transformer
      class ResponseTransformer<T> {
      protected createResponse(id: string, type: string, attributes: T): BaseResponse<T> {
         return {
            id,
            type,
            attributes
         };
      }
      }

      // Specific transformers following LSP
      class UserTransformer extends ResponseTransformer<UserAttributes> {
      transform(user: any): UserResponse {
         return this.createResponse(
            user.id,
            'user',
            {
            email: user.email,
            name: user.name,
            createdAt: new Date(user.createdAt)
            }
         );
      }
      }

      class OrderTransformer extends ResponseTransformer<OrderAttributes> {
      transform(order: any): OrderResponse {
         return this.createResponse(
            order.id,
            'order',
            {
            total: order.total,
            status: order.status,
            items: order.items,
            orderedAt: new Date(order.orderedAt)
            }
         );
      }
      }

      // API Controllers using transformers
      class UserController {
      private transformer = new UserTransformer();

      async getUser(req: Request, res: Response) {
         try {
            const user = await UserService.findById(req.params.id);
            const response = this.transformer.transform(user);
            res.json(response);
         } catch (error) {
            res.status(500).json(this.createErrorResponse(error));
         }
      }

      private createErrorResponse(error: any): BaseResponse<{ message: string }> {
         return {
            id: 'error-' + Date.now(),
            type: 'error',
            attributes: {
            message: error.message
            }
         };
      }
      }

      // Example usage in Express router
      import express from 'express';
      const router = express.Router();
      const userController = new UserController();

      router.get('/api/users/:id', userController.getUser.bind(userController));

      // Collection response handling
      interface CollectionResponse<T> {
      data: BaseResponse<T>[];
      meta: {
         total: number;
         page: number;
         perPage: number;
      };
      }

      class CollectionTransformer<T> extends ResponseTransformer<T> {
      constructor(private itemTransformer: ResponseTransformer<T>) {
         super();
      }

      transformCollection(items: any[], page: number, perPage: number, total: number): CollectionResponse<T> {
         return {
            data: items.map(item => this.itemTransformer.transform(item)),
            meta: {
            total,
            page,
            perPage
            }
         };
      }
      }
   ```
   #### Golang
   ```go
   package main

   import (
      "encoding/json"
      "net/http"
      "time"
   )

   // Base response structure
   type BaseResponse struct {
      ID         string      `json:"id"`
      Type       string      `json:"type"`
      Attributes interface{} `json:"attributes"`
   }

   // Attribute structures for different resources
   type UserAttributes struct {
      Email     string    `json:"email"`
      Name      string    `json:"name"`
      CreatedAt time.Time `json:"createdAt"`
   }

   type OrderAttributes struct {
      Total     float64   `json:"total"`
      Status    string    `json:"status"`
      Items     int       `json:"items"`
      OrderedAt time.Time `json:"orderedAt"`
   }

   type ProductAttributes struct {
      Name     string  `json:"name"`
      Price    float64 `json:"price"`
      Stock    int     `json:"stock"`
      Category string  `json:"category"`
   }

   // Response transformer interface
   type ResponseTransformer interface {
      Transform(interface{}) *BaseResponse
   }

   // Base transformer implementation
   type BaseTransformer struct{}

   func (t *BaseTransformer) CreateResponse(id string, resourceType string, attributes interface{}) *BaseResponse {
      return &BaseResponse{
         ID:         id,
         Type:       resourceType,
         Attributes: attributes,
      }
   }

   // Specific transformers
   type UserTransformer struct {
      BaseTransformer
   }

   func (t *UserTransformer) Transform(user interface{}) *BaseResponse {
      u := user.(User) // Type assertion
      attributes := UserAttributes{
         Email:     u.Email,
         Name:      u.Name,
         CreatedAt: u.CreatedAt,
      }
      return t.CreateResponse(u.ID, "user", attributes)
   }

   type OrderTransformer struct {
      BaseTransformer
   }

   func (t *OrderTransformer) Transform(order interface{}) *BaseResponse {
      o := order.(Order) // Type assertion
      attributes := OrderAttributes{
         Total:     o.Total,
         Status:    o.Status,
         Items:     o.Items,
         OrderedAt: o.OrderedAt,
      }
      return t.CreateResponse(o.ID, "order", attributes)
   }

   // Collection response handling
   type CollectionResponse struct {
      Data  []*BaseResponse `json:"data"`
      Meta  *MetaData      `json:"meta"`
   }

   type MetaData struct {
      Total   int `json:"total"`
      Page    int `json:"page"`
      PerPage int `json:"perPage"`
   }

   // Collection transformer
   type CollectionTransformer struct {
      ItemTransformer ResponseTransformer
   }

   func (t *CollectionTransformer) TransformCollection(items []interface{}, page, perPage, total int) *CollectionResponse {
      data := make([]*BaseResponse, len(items))
      for i, item := range items {
         data[i] = t.ItemTransformer.Transform(item)
      }
      
      return &CollectionResponse{
         Data: data,
         Meta: &MetaData{
               Total:   total,
               Page:    page,
               PerPage: perPage,
         },
      }
   }

   // HTTP handlers
   type UserHandler struct {
      transformer *UserTransformer
   }

   func NewUserHandler() *UserHandler {
      return &UserHandler{
         transformer: &UserTransformer{},
      }
   }

   func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) {
      // Example user data
      user := User{
         ID:        "123",
         Email:     "user@example.com",
         Name:      "John Doe",
         CreatedAt: time.Now(),
      }
      
      response := h.transformer.Transform(user)
      json.NewEncoder(w).Encode(response)
   }

   // Error handling that follows LSP
   type ErrorResponse struct {
      BaseResponse
      Attributes struct {
         Message string `json:"message"`
         Code    string `json:"code"`
      } `json:"attributes"`
   }

   func NewErrorResponse(err error, code string) *ErrorResponse {
      response := &ErrorResponse{}
      response.ID = "error-" + time.Now().Format(time.RFC3339)
      response.Type = "error"
      response.Attributes.Message = err.Error()
      response.Attributes.Code = code
      return response
   }

   // Middleware for consistent error handling
   func ErrorHandler(next http.HandlerFunc) http.HandlerFunc {
      return func(w http.ResponseWriter, r *http.Request) {
         defer func() {
               if err := recover(); err != nil {
                  errorResponse := NewErrorResponse(err.(error), "INTERNAL_SERVER_ERROR")
                  w.WriteHeader(http.StatusInternalServerError)
                  json.NewEncoder(w).Encode(errorResponse)
               }
         }()
         next(w, r)
      }
   }

   func main() {
      handler := NewUserHandler()
      
      // Register routes
      http.HandleFunc("/api/users", ErrorHandler(handler.GetUser))
      http.ListenAndServe(":8080", nil)
   }
   ```
   #### Responses
   ```json
   // Success response
   {
   "id": "123",
   "type": "user",
   "attributes": {
      "email": "user@example.com",
      "name": "John Doe",
      "createdAt": "2024-10-27T12:00:00Z"
   }
   }

   // Error response (follows same structure)
   {
   "id": "error-1234",
   "type": "error",
   "attributes": {
      "message": "User not found",
      "code": "NOT_FOUND"
   }
   }

   // Collection response
   {
   "data": [
      {
         "id": "123",
         "type": "user",
         "attributes": { ... }
      }
   ],
   "meta": {
      "total": 100,
      "page": 1,
      "perPage": 10
   }
   }
   ```

### Interface Segregation Principle (ISP)
1. **API Granularity**
   - Small, focused endpoints over large, generic ones
   - Client-specific endpoints when needed
   - Avoid forcing clients to depend on unnecessary data

2. **Implementation Approaches**
   - Field filtering
   - Sparse fieldsets
   - Custom views for different clients

3. **Example**
   ```sh
   Specific endpoints:
   GET /api/users/{id}/basic-profile
   GET /api/users/{id}/full-profile
   GET /api/users/{id}/preferences
   ```

   #### Type Script
   ```typescript
   // types/user.ts
   interface IBasicProfile {
      id: string;
      name: string;
      email: string;
      avatar: string;
   }

   interface IFullProfile extends IBasicProfile {
      phoneNumber: string;
      address: {
         street: string;
         city: string;
         country: string;
         postalCode: string;
      };
      bio: string;
      socialLinks: {
         twitter?: string;
         linkedin?: string;
         github?: string;
      };
   }

   interface IUserPreferences {
      id: string;
      theme: 'light' | 'dark';
      emailNotifications: boolean;
      pushNotifications: boolean;
      language: string;
      timezone: string;
   }

   // repositories/user.repository.ts
   interface IUserRepository {
      getBasicProfile(id: string): Promise<IBasicProfile>;
      getFullProfile(id: string): Promise<IFullProfile>;
      getPreferences(id: string): Promise<IUserPreferences>;
   }

   class UserRepository implements IUserRepository {
   async getBasicProfile(id: string): Promise<IBasicProfile> {
      // Database query for basic profile only
      return {} as IBasicProfile;
   }

   async getFullProfile(id: string): Promise<IFullProfile> {
      // Database query for full profile
      return {} as IFullProfile;
   }

   async getPreferences(id: string): Promise<IUserPreferences> {
      // Database query for preferences
      return {} as IUserPreferences;
   }
   }

   // services/user.service.ts
   interface IUserService {
      getBasicProfile(id: string): Promise<IBasicProfile>;
      getFullProfile(id: string): Promise<IFullProfile>;
      getPreferences(id: string): Promise<IUserPreferences>;
   }

   class UserService implements IUserService {
   constructor(private readonly userRepository: IUserRepository) {}

   async getBasicProfile(id: string): Promise<IBasicProfile> {
      return this.userRepository.getBasicProfile(id);
   }

   async getFullProfile(id: string): Promise<IFullProfile> {
      return this.userRepository.getFullProfile(id);
   }

   async getPreferences(id: string): Promise<IUserPreferences> {
      return this.userRepository.getPreferences(id);
   }
   }

   // controllers/user.controller.ts
   import { Request, Response } from 'express';
   import { injectable } from 'tsyringe';

   @injectable()
   class UserController {
   constructor(private readonly userService: IUserService) {}

   getBasicProfile = async (req: Request, res: Response): Promise<void> => {
      try {
         const { id } = req.params;
         const profile = await this.userService.getBasicProfile(id);
         res.json(profile);
      } catch (error) {
         res.status(500).json({
         error: 'Failed to fetch basic profile',
         message: error.message
         });
      }
   };

   getFullProfile = async (req: Request, res: Response): Promise<void> => {
      try {
         const { id } = req.params;
         const profile = await this.userService.getFullProfile(id);
         res.json(profile);
      } catch (error) {
         res.status(500).json({
         error: 'Failed to fetch full profile',
         message: error.message
         });
      }
   };

   getPreferences = async (req: Request, res: Response): Promise<void> => {
      try {
         const { id } = req.params;
         const preferences = await this.userService.getPreferences(id);
         res.json(preferences);
      } catch (error) {
         res.status(500).json({
         error: 'Failed to fetch preferences',
         message: error.message
         });
      }
   };
   }

   // routes/user.routes.ts
   import { Router } from 'express';
   import { container } from 'tsyringe';

   const router = Router();
   const userController = container.resolve(UserController);

   router.get('/api/users/:id/basic-profile', userController.getBasicProfile);
   router.get('/api/users/:id/full-profile', userController.getFullProfile);
   router.get('/api/users/:id/preferences', userController.getPreferences);

   export default router;
   ```
   #### Golang
   ```go
   package main

   import (
      "encoding/json"
      "net/http"
      "github.com/gorilla/mux"
   )

   // Domain models
   type BasicProfile struct {
      ID     string `json:"id"`
      Name   string `json:"name"`
      Email  string `json:"email"`
      Avatar string `json:"avatar"`
   }

   type FullProfile struct {
      BasicProfile
      PhoneNumber string `json:"phoneNumber"`
      Address     struct {
         Street     string `json:"street"`
         City       string `json:"city"`
         Country    string `json:"country"`
         PostalCode string `json:"postalCode"`
      } `json:"address"`
      Bio         string `json:"bio"`
      SocialLinks struct {
         Twitter  string `json:"twitter,omitempty"`
         LinkedIn string `json:"linkedin,omitempty"`
         GitHub   string `json:"github,omitempty"`
      } `json:"socialLinks"`
   }

   type UserPreferences struct {
      ID                 string `json:"id"`
      Theme             string `json:"theme"`
      EmailNotifications bool   `json:"emailNotifications"`
      PushNotifications  bool   `json:"pushNotifications"`
      Language          string `json:"language"`
      Timezone          string `json:"timezone"`
   }

   // Repository interfaces
   type BasicProfileRepository interface {
      GetBasicProfile(id string) (*BasicProfile, error)
   }

   type FullProfileRepository interface {
      GetFullProfile(id string) (*FullProfile, error)
   }

   type PreferencesRepository interface {
      GetPreferences(id string) (*UserPreferences, error)
   }

   // Combined repository interface (for implementation)
   type UserRepository interface {
      BasicProfileRepository
      FullProfileRepository
      PreferencesRepository
   }

   // Repository implementation
   type PostgresUserRepository struct {
      db *sql.DB
   }

   func (r *PostgresUserRepository) GetBasicProfile(id string) (*BasicProfile, error) {
      // Implementation for fetching basic profile
      return &BasicProfile{}, nil
   }

   func (r *PostgresUserRepository) GetFullProfile(id string) (*FullProfile, error) {
      // Implementation for fetching full profile
      return &FullProfile{}, nil
   }

   func (r *PostgresUserRepository) GetPreferences(id string) (*UserPreferences, error) {
      // Implementation for fetching preferences
      return &UserPreferences{}, nil
   }

   // Service interfaces
   type BasicProfileService interface {
      GetBasicProfile(id string) (*BasicProfile, error)
   }

   type FullProfileService interface {
      GetFullProfile(id string) (*FullProfile, error)
   }

   type PreferencesService interface {
      GetPreferences(id string) (*UserPreferences, error)
   }

   // Service implementation
   type UserService struct {
      repo UserRepository
   }

   func NewUserService(repo UserRepository) *UserService {
      return &UserService{repo: repo}
   }

   func (s *UserService) GetBasicProfile(id string) (*BasicProfile, error) {
      return s.repo.GetBasicProfile(id)
   }

   func (s *UserService) GetFullProfile(id string) (*FullProfile, error) {
      return s.repo.GetFullProfile(id)
   }

   func (s *UserService) GetPreferences(id string) (*UserPreferences, error) {
      return s.repo.GetPreferences(id)
   }

   // HTTP handlers
   type UserHandler struct {
      service *UserService
   }

   func NewUserHandler(service *UserService) *UserHandler {
      return &UserHandler{service: service}
   }

   func (h *UserHandler) GetBasicProfile(w http.ResponseWriter, r *http.Request) {
      vars := mux.Vars(r)
      id := vars["id"]

      profile, err := h.service.GetBasicProfile(id)
      if err != nil {
         http.Error(w, "Failed to fetch basic profile", http.StatusInternalServerError)
         return
      }

      json.NewEncoder(w).Encode(profile)
   }

   func (h *UserHandler) GetFullProfile(w http.ResponseWriter, r *http.Request) {
      vars := mux.Vars(r)
      id := vars["id"]

      profile, err := h.service.GetFullProfile(id)
      if err != nil {
         http.Error(w, "Failed to fetch full profile", http.StatusInternalServerError)
         return
      }

      json.NewEncoder(w).Encode(profile)
   }

   func (h *UserHandler) GetPreferences(w http.ResponseWriter, r *http.Request) {
      vars := mux.Vars(r)
      id := vars["id"]

      preferences, err := h.service.GetPreferences(id)
      if err != nil {
         http.Error(w, "Failed to fetch preferences", http.StatusInternalServerError)
         return
      }

      json.NewEncoder(w).Encode(preferences)
   }

   // Router setup
   func setupRoutes(handler *UserHandler) *mux.Router {
      router := mux.NewRouter()
      
      router.HandleFunc("/api/users/{id}/basic-profile", handler.GetBasicProfile).Methods("GET")
      router.HandleFunc("/api/users/{id}/full-profile", handler.GetFullProfile).Methods("GET")
      router.HandleFunc("/api/users/{id}/preferences", handler.GetPreferences).Methods("GET")
      
      return router
   }

   func main() {
      // Setup dependencies
      repo := &PostgresUserRepository{}
      service := NewUserService(repo)
      handler := NewUserHandler(service)
      
      router := setupRoutes(handler)
      http.ListenAndServe(":8080", router)
   }
   ```

   #### Responses
   ```json
   // GET /api/users/{id}/basic-profile
   {
   "id": "123",
   "name": "John Doe",
   "email": "john@example.com",
   "avatar": "https://..."
   }

   // GET /api/users/{id}/full-profile
   {
   "id": "123",
   "name": "John Doe",
   "email": "john@example.com",
   "avatar": "https://...",
   "phoneNumber": "+1234567890",
   "address": {
      "street": "123 Main St",
      "city": "New York",
      "country": "USA",
      "postalCode": "10001"
   },
   "bio": "Software Engineer",
   "socialLinks": {
      "twitter": "@johndoe",
      "linkedin": "johndoe",
      "github": "johndoe"
   }
   }

   // GET /api/users/{id}/preferences
   {
   "id": "123",
   "theme": "dark",
   "emailNotifications": true,
   "pushNotifications": false,
   "language": "en",
   "timezone": "UTC-5"
   }
   ```

### Dependency Inversion Principle (DIP)
1. **API Abstraction**
   - Depend on abstractions, not concrete implementations
   - Use interface-based contracts
   - Abstract underlying systems

2. **Implementation Guidelines**
   - Generic resource interfaces
   - Standard response formats
   - Consistent error handling

![Class Diagram](./images/ch2/2.1.svg)

```mermaid
classDiagram
    IConnectable <|-- IDatabase
    IQueryable <|-- IDatabase
    IExecutor <|-- IDatabase
    ITransactional <|-- IDatabase
    IQueryable <|-- ITransaction
    IExecutor <|-- ITransaction
    IRow <|.. sqlRowAdapter
    IRows <|.. sqlRowsAdapter

    class IConnectable {
        <<interface>>
        +Connect()
        +Disconnect()
        +Ping()
    }
    class IQueryable {
        <<interface>>
        +Query()
        +QueryRow()
    }
    class IExecutor {
        <<interface>>
        +ExecuteNonQuery()
        +ExecuteScalar()
    }
    class ITransactional {
        <<interface>>
        +BeginTx()
    }
    class ITransaction {
        <<interface>>
        +Commit()
        +Rollback()
    }
    class IRows {
        <<interface>>
        +Next()
        +Scan()
        +Close()
        +Columns()
        +Err()
    }
    class IRow {
        <<interface>>
        +Scan()
        +Err()
    }
    class IResult {
        <<interface>>
        +LastInsertId()
        +RowsAffected()
    }
    class IDatabase {
        <<interface>>
    }
    class DatabaseConfig {
        +Provider
        +Host
        +Port
        +Username
        +Password
        +Database
        +SSLMode
        +Options
    }
    class sqlRowAdapter {
        -row
        +Scan()
        +Err()
    }
    class sqlRowsAdapter {
        -rows
        +Next()
        +Scan()
        +Close()
        +Columns()
        +Err()
    }
```

#### Typescript
```typescript
// Service interface that each implementation must satisfy
interface Service {
    execute(): string;
}

// Implementation 1
class ServiceA implements Service {
    execute(): string {
        return "ServiceA Executed";
    }
}

// Implementation 2
class ServiceB implements Service {
    execute(): string {
        return "ServiceB Executed";
    }
}

class ServiceContainer {
    private services: Map<string, Service>;

    constructor() {
        this.services = new Map<string, Service>();
    }

    // Method to add a service to the container
    addService(key: string, service: Service): void {
        this.services.set(key, service);
    }

    // Method to retrieve a service by key
    getService(key: string): Service | undefined {
        return this.services.get(key);
    }
}

function main() {
    const container = new ServiceContainer();

    // Add services with specific keys
    container.addService("serviceA", new ServiceA());
    container.addService("serviceB", new ServiceB());

    // Retrieve and use services by key
    const serviceA = container.getService("serviceA");
    if (serviceA) {
        console.log(serviceA.execute());
    }
    
    const serviceB = container.getService("serviceB");
    if (serviceB) {
        console.log(serviceB.execute());
    }
}

main();
```

#### Golang
```go
package main

import "fmt"

// Service interface that each implementation must satisfy
type Service interface {
    Execute() string
}

// Implementation 1
type ServiceA struct{}

func (s *ServiceA) Execute() string {
    return "ServiceA Executed"
}

// Implementation 2
type ServiceB struct{}

func (s *ServiceB) Execute() string {
    return "ServiceB Executed"
}

type ServiceContainer struct {
    services map[string]Service
}

// Method to add a service to the container
func (sc *ServiceContainer) AddService(key string, service Service) {
    sc.services[key] = service
}

// Method to retrieve a service by key
func (sc *ServiceContainer) GetService(key string) (Service, bool) {
    service, exists := sc.services[key]
    return service, exists
}

func main() {
    container := ServiceContainer{services: make(map[string]Service)}

    // Add services with specific keys
    container.AddService("serviceA", &ServiceA{})
    container.AddService("serviceB", &ServiceB{})

    // Retrieve and use services by key
    if service, found := container.GetService("serviceA"); found {
        fmt.Println(service.Execute())
    }
    
    if service, found := container.GetService("serviceB"); found {
        fmt.Println(service.Execute())
    }
}
```


## REST Constraints and Principles

### Client-Server Architecture
1. **Separation of Concerns**
   - Clear division between client and server
   - Independent evolution
   - Improved scalability

2. **Key Benefits**
   - Portability of client code
   - Scalability of server components
   - Independent development

### Statelessness
1. **Core Requirements**
   - No client context stored on server
   - Each request contains all needed information
   - Session state maintained by client

2. **Implementation Guidelines**
   - Use authentication tokens
   - Include necessary context in requests
   - Avoid server-side sessions

3. **Example**
   ```text
   Stateless:
   GET /api/orders?page=2&pageSize=10
   Authorization: Bearer <token>

   Stateful (Avoid):
   GET /api/orders/next-page
   Session: <session-id>
   ```

   #### Type Script
   ```typescript
   // types.ts
   interface Order {
      id: string;
      customerId: string;
      amount: number;
      status: string;
      createdAt: Date;
   }

   interface PaginatedResponse<T> {
      data: T[];
      metadata: {
         currentPage: number;
         pageSize: number;
         totalPages: number;
         totalItems: number;
         hasNextPage: boolean;
         hasPreviousPage: boolean;
   };
   }

   interface PaginationParams {
      page: number;
      pageSize: number;
      sortBy?: string;
      sortDirection?: 'asc' | 'desc';
   }

   // services/order.service.ts
   class OrderService {
   private orders: Order[] = []; // Simulated database

   // Stateless approach - Recommended
   async getOrdersPaginated(params: PaginationParams): Promise<PaginatedResponse<Order>> {
      const { page, pageSize, sortBy = 'createdAt', sortDirection = 'desc' } = params;
      
      // Validate pagination parameters
      const validatedPage = Math.max(1, page);
      const validatedPageSize = Math.min(100, Math.max(1, pageSize));
      
      // Calculate skip and take
      const skip = (validatedPage - 1) * validatedPageSize;
      
      // Get total count (in real app, this would be a DB count query)
      const totalItems = this.orders.length;
      
      // Sort and paginate (in real app, this would be part of DB query)
      const paginatedOrders = [...this.orders]
         .sort((a: any, b: any) => {
         return sortDirection === 'asc' 
            ? a[sortBy] - b[sortBy]
            : b[sortBy] - a[sortBy];
         })
         .slice(skip, skip + validatedPageSize);
      
      return {
         data: paginatedOrders,
         metadata: {
         currentPage: validatedPage,
         pageSize: validatedPageSize,
         totalPages: Math.ceil(totalItems / validatedPageSize),
         totalItems,
         hasNextPage: skip + validatedPageSize < totalItems,
         hasPreviousPage: validatedPage > 1
         }
      };
   }
   
   // Stateful approach - Not Recommended
   private sessionCursors: Map<string, { 
      currentPage: number; 
      pageSize: number; 
      lastAccessTime: Date;
   }> = new Map();
   
   async getOrdersWithCursor(
      sessionId: string, 
      direction: 'next' | 'prev' = 'next'
   ): Promise<PaginatedResponse<Order>> {
      // Get or initialize session state
      let cursor = this.sessionCursors.get(sessionId);
      if (!cursor) {
         cursor = { currentPage: 1, pageSize: 10, lastAccessTime: new Date() };
         this.sessionCursors.set(sessionId, cursor);
      }
      
      // Update page based on direction
      if (direction === 'next') {
         cursor.currentPage++;
      } else if (direction === 'prev') {
         cursor.currentPage = Math.max(1, cursor.currentPage - 1);
      }
      
      // Update last access time
      cursor.lastAccessTime = new Date();
      
      // Get orders using the cursor state
      return this.getOrdersPaginated({
         page: cursor.currentPage,
         pageSize: cursor.pageSize
      });
   }
   
   // Cleanup old sessions (should be called periodically)
      private cleanupOldSessions(maxAgeMinutes: number = 30): void {
         const now = new Date();
         for (const [sessionId, cursor] of this.sessionCursors.entries()) {
            const ageMinutes = (now.getTime() - cursor.lastAccessTime.getTime()) / (1000 * 60);
            if (ageMinutes > maxAgeMinutes) {
            this.sessionCursors.delete(sessionId);
            }
         }
      }
   }

   // controllers/order.controller.ts
   import express, { Request, Response } from 'express';
   import { authenticateToken } from '../middleware/auth';

   const router = express.Router();
   const orderService = new OrderService();

   // Stateless endpoint - Recommended
   router.get(
   '/api/orders',
   authenticateToken,
   async (req: Request, res: Response) => {
      try {
         const page = parseInt(req.query.page as string) || 1;
         const pageSize = parseInt(req.query.pageSize as string) || 10;
         const sortBy = req.query.sortBy as string;
         const sortDirection = req.query.sortDirection as 'asc' | 'desc';

         const result = await orderService.getOrdersPaginated({
         page,
         pageSize,
         sortBy,
         sortDirection
         });

         res.json(result);
      } catch (error) {
         res.status(500).json({ 
         error: 'Failed to fetch orders',
         details: error instanceof Error ? error.message : 'Unknown error'
         });
      }
   }
   );

   // Example usage:
   // GET /api/orders?page=2&pageSize=10&sortBy=createdAt&sortDirection=desc

   // Stateful endpoint - Not Recommended
   router.get(
   '/api/orders/cursor',
   authenticateToken,
   async (req: Request, res: Response) => {
      try {
         const sessionId = req.headers['session-id'] as string;
         if (!sessionId) {
         return res.status(400).json({ error: 'Session ID is required' });
         }

         const direction = req.query.direction as 'next' | 'prev' || 'next';
         
         const result = await orderService.getOrdersWithCursor(sessionId, direction);
         res.json(result);
      } catch (error) {
         res.status(500).json({ 
         error: 'Failed to fetch orders',
         details: error instanceof Error ? error.message : 'Unknown error'
         });
      }
   }
   );

   // Example usage:
   // GET /api/orders/cursor?direction=next
   // Headers: session-id: abc123

   // middleware/auth.ts
   import { Request, Response, NextFunction } from 'express';

   export function authenticateToken(
      req: Request,
      res: Response,
      next: NextFunction
   ) {
   const authHeader = req.headers['authorization'];
   const token = authHeader && authHeader.split(' ')[1];

   if (!token) {
      return res.status(401).json({ error: 'Authentication token is required' });
   }

   try {
      // Validate token here
      // jwt.verify(token, process.env.JWT_SECRET);
      next();
   } catch (error) {
      return res.status(403).json({ error: 'Invalid or expired token' });
   }
   }

   // Example client usage:
   
   // Stateless approach (Recommended)
   async function fetchOrders(page: number, pageSize: number) {
   const response = await fetch(
      `/api/orders?page=${page}&pageSize=${pageSize}`,
      {
         headers: {
         'Authorization': `Bearer ${token}`
         }
      }
   );
   return response.json();
   }

   // Stateful approach (Not Recommended)
   async function fetchNextPage() {
   const response = await fetch(
      '/api/orders/cursor?direction=next',
      {
         headers: {
         'Authorization': `Bearer ${token}`,
         'Session-ID': 'abc123'
         }
      }
   );
   return response.json();
   }
   
   ```

### Cacheability
1. **Cache Controls**
   - Explicit cache directives
   - ETag implementation
   - Last-Modified headers

2. **Best Practices**
   - Cache-Control headers
   - Conditional requests
   - Cache invalidation strategies

3. **Example Headers**
   ```text
   Cache-Control: public, max-age=3600
   ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
   Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT
   ```

   ### Cache Control Flow
   ![cache control](./images/ch1/1.2.2.png)
   
   #### Type Script
   ```typescript
   // types.ts
   interface CacheableResource {
      id: string;
      data: any;
      lastModified: Date;
      etag: string;
   }

   interface CacheConfig {
      maxAge: number;  // in seconds
      public: boolean;
      mustRevalidate: boolean;
   }

   // utils/cache.utils.ts
   import crypto from 'crypto';

   export class CacheUtils {
   static generateETag(data: any): string {
      return crypto
         .createHash('sha256')
         .update(JSON.stringify(data))
         .digest('hex');
   }

   static formatLastModified(date: Date): string {
      return date.toUTCString();
   }

   static parseCacheControl(header: string): Record<string, string | number | boolean> {
      const directives: Record<string, string | number | boolean> = {};
      
      if (!header) return directives;

      header.split(',').forEach(directive => {
         const [key, value] = directive.trim().split('=');
         directives[key] = value === undefined ? true : value;
      });

      return directives;
   }
   }

   // middleware/cache.middleware.ts
   import { Request, Response, NextFunction } from 'express';
   import { CacheUtils } from '../utils/cache.utils';

   export interface CacheOptions {
      maxAge?: number;
      public?: boolean;
      private?: boolean;
      noCache?: boolean;
      noStore?: boolean;
      mustRevalidate?: boolean;
   }

   export function setCacheHeaders(options: CacheOptions = {}) {
   return (req: Request, res: Response, next: NextFunction) => {
      const directives: string[] = [];

      if (options.public) directives.push('public');
      if (options.private) directives.push('private');
      if (options.noCache) directives.push('no-cache');
      if (options.noStore) directives.push('no-store');
      if (options.mustRevalidate) directives.push('must-revalidate');
      if (options.maxAge) directives.push(`max-age=${options.maxAge}`);

      if (directives.length > 0) {
         res.setHeader('Cache-Control', directives.join(', '));
      }

      next();
   };
   }

   export function conditionalGet() {
   return async (req: Request, res: Response, next: NextFunction) => {
      const resource = res.locals.resource;
      
      if (!resource) {
         next();
         return;
      }

      const ifNoneMatch = req.header('If-None-Match');
      const ifModifiedSince = req.header('If-Modified-Since');

      // ETag validation
      if (ifNoneMatch && resource.etag === ifNoneMatch) {
         res.status(304).end();
         return;
      }

      // Last-Modified validation
      if (ifModifiedSince && resource.lastModified) {
         const clientDate = new Date(ifModifiedSince);
         if (resource.lastModified <= clientDate) {
         res.status(304).end();
         return;
         }
      }

      next();
   };
   }

   // services/resource.service.ts
   class ResourceService {
   private resources: Map<string, CacheableResource> = new Map();

   async getResource(id: string): Promise<CacheableResource | null> {
      const resource = this.resources.get(id);
      return resource || null;
   }

   async updateResource(id: string, data: any): Promise<CacheableResource> {
      const resource: CacheableResource = {
         id,
         data,
         lastModified: new Date(),
         etag: CacheUtils.generateETag(data)
      };

      this.resources.set(id, resource);
      return resource;
   }
   }

   // controllers/resource.controller.ts
   import express from 'express';
   import { setCacheHeaders, conditionalGet } from '../middleware/cache.middleware';

   const router = express.Router();
   const resourceService = new ResourceService();

   // Example of a cached endpoint
   router.get(
   '/api/resources/:id',
   setCacheHeaders({
      public: true,
      maxAge: 3600,  // 1 hour
      mustRevalidate: true
   }),
   async (req: Request, res: Response, next: NextFunction) => {
      try {
         const resource = await resourceService.getResource(req.params.id);
         
         if (!resource) {
         return res.status(404).json({ error: 'Resource not found' });
         }

         // Set resource for conditional GET middleware
         res.locals.resource = resource;
         
         // Set caching headers
         res.setHeader('ETag', resource.etag);
         res.setHeader('Last-Modified', CacheUtils.formatLastModified(resource.lastModified));

         next();
      } catch (error) {
         next(error);
      }
   },
   conditionalGet(),
   async (req: Request, res: Response) => {
      // If we get here, client needs the full response
      res.json(res.locals.resource.data);
   }
   );

   // Example usage with fetch API:
   
   async function fetchResource(id: string) {
   const response = await fetch(`/api/resources/${id}`, {
      headers: {
         'If-None-Match': localStorage.getItem(`etag_${id}`),
         'If-Modified-Since': localStorage.getItem(`lastModified_${id}`)
      }
   });

   if (response.status === 304) {
      // Resource hasn't changed, use cached version
      return JSON.parse(localStorage.getItem(`resource_${id}`) || '');
   }

   // Store new ETag and Last-Modified headers
   const etag = response.headers.get('ETag');
   const lastModified = response.headers.get('Last-Modified');
   
   if (etag) localStorage.setItem(`etag_${id}`, etag);
   if (lastModified) localStorage.setItem(`lastModified_${id}`, lastModified);

   const data = await response.json();
   localStorage.setItem(`resource_${id}`, JSON.stringify(data));
   return data;
   }

   // Example implementation with axios:
   import axios from 'axios';

   const api = axios.create();

   // Add cache interceptor
   api.interceptors.request.use(config => {
   const resourceId = // extract from URL
   const etag = localStorage.getItem(`etag_${resourceId}`);
   const lastModified = localStorage.getItem(`lastModified_${resourceId}`);

   if (etag) {
      config.headers['If-None-Match'] = etag;
   }
   if (lastModified) {
      config.headers['If-Modified-Since'] = lastModified;
   }

   return config;
   });

   api.interceptors.response.use(
   response => {
      const resourceId = // extract from URL
      const etag = response.headers['etag'];
      const lastModified = response.headers['last-modified'];

      if (etag) localStorage.setItem(`etag_${resourceId}`, etag);
      if (lastModified) localStorage.setItem(`lastModified_${resourceId}`, lastModified);

      return response;
   }
   );
   
   ```

### Uniform Interface
1. **Resource Identification**
   - Unique resource identifiers
   - Consistent naming conventions
   - Clear resource relationships

2. **Resource Manipulation through Representations**
   - Standard data formats
   - Self-descriptive messages
   - HATEOAS implementation

3. **Example Implementation**
   ```json
   Resource URI:
   /api/orders/{id}

   Representation:
   {
     "id": "123",
     "status": "pending",
     "_links": {
       "self": "/api/orders/123",
       "items": "/api/orders/123/items"
     }
   }
   ```

## Richardson Maturity Model

### Level 0: The Swamp of POX
1. **Characteristics**
   - Single endpoint
   - HTTP as tunnel
   - RPC-style interactions

2. **Example**
   ```json
   POST /api/service
   {
     "method": "getUser",
     "id": "123"
   }
   ```

### Level 1: Resources
1. **Characteristics**
   - Individual resources
   - Multiple endpoints
   - Still RPC-style methods

2. **Example**
   ```text
   POST /api/users/123/get
   POST /api/users/123/update
   ```

### Level 2: HTTP Verbs
1. **Characteristics**
   - Proper HTTP methods
   - Status codes
   - Standard headers

2. **Example**
   ```text
   GET /api/users/123
   PUT /api/users/123
   DELETE /api/users/123
   ```

### Level 3: Hypermedia Controls (HATEOAS)
1. **Characteristics**
   - Self-documenting APIs
   - Resource discovery
   - State transitions

2. **Example**
   ```json
   {
     "id": "123",
     "status": "pending",
     "_links": {
       "self": { "href": "/api/orders/123" },
       "cancel": { "href": "/api/orders/123/cancel" },
       "update": { "href": "/api/orders/123" }
     }
   }
   ```

## API-First Design Approach

### Design Phase
1. **Contract Development**
   - OpenAPI/Swagger specification
   - Data models
   - Endpoint definitions

2. **Stakeholder Review**
   - Developer feedback
   - Client requirements
   - Technical constraints

### Development Process
1. **Mock Implementation**
   - API mocking tools
   - Test scenarios
   - Client development support

2. **Parallel Development**
   - Frontend development
   - Backend implementation
   - Integration testing

### Documentation
1. **API Documentation**
   - Interactive documentation
   - Code examples
   - Use cases

2. **Style Guidelines**
   - Naming conventions
   - Response formats
   - Error handling

### Practical Implementation
1. **Tools and Technologies**
   - API design tools
   - Documentation generators
   - Testing frameworks

2. **Best Practices**
   - Version control for specifications
   - Automated testing
   - Continuous integration
